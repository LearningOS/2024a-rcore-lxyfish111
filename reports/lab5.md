实现的功能
设置个flag在tcb上，标记task是否开启检查，并在对应的互斥和信号量函数里做检查。修改其他相关文件。

问答题
答：当主线程退出时，需要回收所有子线程的资源，包括栈内存、堆内存、锁资源等，并且需要确保TCB在所有引用位置被正确处理和回收，以避免资源泄漏和其他问题

Mutex1 的实现：
mutex_inner.locked状态的更新是在检查是否有等待的任务之前。
这意味着无论是否有等待的任务，locked状态都会被设置为false。
Mutex2 的实现：
mutex_inner.locked状态的更新是在检查是否有等待的任务之后。
如果有等待的任务，locked状态不会被更新，因为新的线程将接管锁。
只有当没有等待的任务时，locked状态才会被设置为false。

Mutex1的实现可能会导致死锁，因为它不检查是否有等待的任务就释放了锁。
Mutex2的实现可能会导致竞态条件，如果locked状态的更新时机不当。
Mutex2的实现可能在某些情况下提供更好的性能，因为它减少了不必要的上下文切换。

荣誉准则
在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：
网上搜索

此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：
网上搜索

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。