实现功能：
修改sys_get_time和sys_task_info函数实现并添加必要代码。实现sys_mmap和sys_munmap函数并添加必要修改代码。

问答题：
1.答：在 RISC-V 架构中，SV39（Supervisor Mode 39-bit）是一种页表格式，用于实现虚拟内存管理。SV39 页表项（Page Table Entry, PTE）的组成如下：

PPN（Physical Page Number）：物理页号，用于存储物理页的地址。在 SV39 中，PPN 占用 39 位，这意味着可以直接访问高达 512TB 的物理内存。

READ：读权限标志位，用于指示是否有权限从该页读取数据。

WRITE：写权限标志位，用于指示是否有权限向该页写入数据。

EXECUTE：执行权限标志位，用于指示是否有权限从该页执行代码。

SW：共享/弱缓存标志位，用于控制页是否可以被缓存。

UR：用户模式可读标志位，用于控制用户模式下是否可以读取该页。

UW：用户模式可写标志位，用于控制用户模式下是否可以写入该页。

UX：用户模式可执行标志位，用于控制用户模式下是否可以执行该页。

G：全局标志位，用于控制页是否在TLB（Translation Lookaside Buffer）中全局可见。

A：访问标志位，用于指示页是否被访问过。

D：脏标志位，用于指示页是否被写过。

V：有效标志位，用于指示页表项是否有效。

这些标志位的作用如下：

READ/WRITE/EXECUTE：控制对页的访问权限，确保只有具有相应权限的进程或模式可以访问页。
SW：影响页的缓存策略，通常用于控制页是否可以被缓存。
UR/UW/UX：控制用户模式下的访问权限，确保用户模式下的进程不能违反权限规则。
G：影响页在TLB中的可见性，全局页在所有地址空间中都可见。
A/D：用于跟踪页的使用情况，A 标志位在页被访问时设置，D 标志位在页被写入时设置。
V：指示页表项是否有效，无效的页表项不能用于地址转换。
SV39 页表项的设计允许灵活的内存管理，包括权限控制、缓存控制和TLB管理。这些标志位的组合使得操作系统可以根据需要配置页表项，以实现不同的内存访问策略和保护机制。

2.答：哪些异常可能是缺页导致的？
在操作系统中，缺页通常会导致一个特定的异常或中断，这个异常被称为“缺页异常”（Page Fault）。当处理器尝试访问一个不在物理内存中的页时，会触发这个异常。具体来说，以下几种情况可能引起缺页异常：

访问未分配的页：进程尝试访问的虚拟内存页面在页表中没有对应的条目。
访问无效的页：进程尝试访问的页面在页表中有条目，但该条目标记为无效。
权限不足：进程尝试以不允许的方式（如写入只读页）访问页面。
发生缺页时，描述相关重要寄存器的值
在发生缺页时，处理器和操作系统会保存一些关键的寄存器值，以便处理异常。这些寄存器包括：

程序计数器（PC）：保存触发缺页异常的指令地址。
指令寄存器（IR）：保存触发缺页的指令。
链接寄存器（LR）：在某些架构中，保存返回地址，用于函数调用返回。
内存访问寄存器：保存导致缺页的内存地址。
懒加载（Lazy Loading）的好处
懒加载策略的好处包括：

减少启动时间：程序启动时不需要立即加载所有代码和数据，可以快速启动。
节省内存：只有实际需要的代码和数据才会被加载到内存中，减少了内存的占用。
按需加载：可以根据实际使用情况动态加载页面，提高资源利用率。
实际的内存占用可能会因为页表的层次结构和额外的元数据而有所不同。

实现 Lazy 策略和缺页处理
实现懒加载策略，可以采取以下步骤：

延迟分配：在页表项中，不立即分配物理内存，而是标记为“未分配”或“无效”。
缺页处理：当发生缺页异常时，操作系统检查页表项，如果发现是“未分配”，则从磁盘加载所需的页面到物理内存，并更新页表项。
优化性能：可以使用缓存和预加载策略来减少缺页的次数。
缺页处理通常涉及以下步骤：

识别缺页：捕获缺页异常，并确定导致异常的虚拟地址。
加载页面：从磁盘或其他存储介质加载页面到物理内存。
更新页表：更新页表项，标记页面为有效，并设置适当的权限。
重新执行指令：恢复寄存器状态，并重新执行导致缺页的指令。
页面失效在页表项（PTE）上的表现
在页表项（PTE）上，页面失效可能表现为：

无效标志：PTE 中的有效位（V）被设置为 0，表示该页表项无效。
访问权限：PTE 中的权限位（如读、写、执行）可能不匹配访问请求，导致访问违规。
修改和访问位：PTE 中的修改（D）和访问（A）位可以用于跟踪页面的使用情况，但它们并不直接指示页面失效。
通过检查这些标志位，操作系统可以确定页面是否有效，以及是否需要进行页面加载或替换操作。

3.答：在单页表情况下，如何更换页表？
在单页表情况下，更换页表通常涉及到修改控制寄存器中的页表基地址。在x86架构中，这个寄存器是CR3（Page-Directory Base Register），在RISC-V中，对应的寄存器是satp（Supervisor Address Translation and Protection）。更换页表的过程通常如下：

准备新的页表：在内存中创建并初始化一个新的页表。
更新页表基地址：将新的页表的物理地址写入控制寄存器，这将使CPU的MMU（Memory Management Unit）开始使用新的页表。
刷新TLB：由于TLB（Translation Lookaside Buffer）可能缓存了旧页表的翻译结果，需要刷新TLB以确保后续的地址翻译使用新的页表。
切换地址空间：在操作系统中，这可能涉及到更新进程或线程的数据结构，以反映页表的更换。
单页表情况下，如何控制用户态无法访问内核页面？
在单页表情况下，控制用户态无法访问内核页面通常通过以下方法：

权限位：在页表项中设置权限位，确保内核页面对于用户态是不可见或不可访问的。例如，在x86中，页表项的U/S（User/Supervisor）位可以用来控制用户态是否可以访问。
地址空间布局：将内核空间布局在高地址，用户空间布局在低地址，这样可以通过地址范围来限制访问。
MMU配置：配置MMU以确保用户态的地址翻译不会涉及到内核空间的页表项。
单页表有何优势？
单页表的优势包括：

简化设计：不需要维护两套页表，简化了操作系统的内存管理设计。
减少内存开销：只需要一套页表，减少了内存的使用。
提高效率：在某些情况下，单页表可以减少页表切换的开销，因为不需要在用户态和内核态之间频繁切换页表。
双页表实现下，何时需要更换页表？
在双页表实现下，更换页表的情况可能包括：

进程切换：在进程上下文切换时，需要更换页表以反映新进程的地址空间。
加载模块或驱动：当操作系统加载新的模块或驱动时，可能需要更新页表以包含新的代码和数据。
内存映射：在进行内存映射操作（如mmap）时，需要更新页表以包含新的映射。
权限变更：当内存区域的权限需要变更时，可能需要更新页表项的权限位。
假设你写一个单页表操作系统，你会选择何时更换页表？
如果选择实现单页表操作系统，更换页表的时机可能包括：

系统启动：在系统启动时，从初始的启动页表切换到主操作系统的页表。
用户登录：在用户登录时，为每个用户会话创建和切换到新的页表，以隔离不同用户的地址空间。
执行新程序：在执行新程序时，如果程序需要特定的内存布局或权限设置，可能需要更换页表。
安全上下文切换：在进行安全敏感的操作时，可能需要切换到一个安全的页表，以保护敏感数据。
在设计单页表操作系统时，需要仔细考虑何时以及如何更换页表，以确保系统的安全性和效率。

荣誉准则
1.在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

群里同学和助教

2.此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：


3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。

