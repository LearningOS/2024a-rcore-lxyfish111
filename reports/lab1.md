实现的功能
修改TaskControlBlock结构体，添加syscall_times和time字段。
syscall_times记录系统api回调次数，time记录第一次启动task的时间。
在sys_task_info中从TaskControlBlock中获取所需的数据。

简答题
题1.
ch2b_bad_address.rs：
尝试在U态（用户态）执行一个S态（超级用户态）的特权操作，即尝试向一个非法地址（0x0）写入数据。
ch2b_bad_instructions.rs
sret指令是RISC-V架构中用于从S态返回到U态的指令。然而，这段代码是在U态（用户态）中尝试执行这个指令，这是不允许的，因为它是一个特权指令，只能在S态（超级用户态）中执行。
ch2b_bad_register.rs：
尝试在用户态（U态）读取RISC-V架构中的sstatus寄存器的值。sstatus寄存器是一个特权寄存器，通常只能在超级用户态（S态）下访问。

题2.
1.刚进入 __restore 时，a0 寄存器代表了 Trap 上下文（TrapContext）的地址，这个地址指向内核栈上保存的 Trap 上下文结构，其中包含了用户态寄存器的状态和一些控制状态寄存器（CSR）的值。

__restore 的两种使用情景包括：

启动应用程序：系统启动时，从内核态进入用户态运行第一个应用程序，此时 __restore 用于设置初始的 Trap 上下文，使得应用程序可以从用户态开始执行。
中断或异常处理后返回用户态：当处理完一个中断或异常后，需要从内核态返回到引起中断或异常的用户态程序，__restore 用于恢复之前保存的 Trap 上下文，以便用户程序能够从被中断的地方继续执行。

2.寄存器有t0, t1, t2。
这些寄存器的值对于进入用户态有以下意义：
sstatus（通过t0加载）：sstatus是S态（超级用户态）的状态寄存器，控制着S态的全局中断使能和其他状态标志。在进入用户态之前，需要正确设置sstatus以确保用户态的行为符合预期，比如使能或禁用中断。
sepc（通过t1加载）：sepc是S态的异常程序计数器，用于记录发生异常时的指令地址。在从S态返回到U态时，需要设置sepc以确保用户程序从正确的地址开始执行。
sscratch（通过t2加载）：sscratch是S态的临时寄存器，用于保存S态下的重要数据，以便在S态和U态之间共享或传递信息。
通过这些寄存器的设置，__restore函数确保了从S态到U态的转换能够正确地恢复用户态程序的执行环境，包括程序计数器、状态标志和临时数据。

3.x2和x4被跳过的原因可能是因为它们被用作了其他特定的目的。

4.这条指令实现了sp和sscratch寄存器值的交换，其目的是为了在不同特权级别间切换时保存和恢复栈指针。这样，当控制权从内核态返回到用户态时，用户程序可以继续使用其自己的栈，而内核在处理中断或异常时可以使用内核栈。

5.在 __restore 函数中，状态切换发生在 sret 指令执行的地方。这条指令执行之后会进入用户态（U态），原因在于 sret 指令是RISC-V架构中用于从S态（超级用户态）返回到U态（用户态）的特权指令。

6.这条指令实现了sp和sscratch寄存器值的交换，其目的是为了在不同特权级别间切换时保存和恢复栈指针。这样，当控制权从内核态返回到用户态时，用户程序可以继续使用其自己的栈，而内核在处理中断或异常时可以使用内核栈。

7.从U态进入S态的指令是ecall。在RISC-V架构中，当在用户模式（U态）下执行ecall指令时，会触发一个环境调用异常，导致处理器从U态切换到更高的特权模式，通常是监督模式（S态）。

在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

微信群里助教和其他一些热心同学。

此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

https://learningos.cn/rCore-Camp-Guide-2024A/chapter3/5exercise.html

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。

